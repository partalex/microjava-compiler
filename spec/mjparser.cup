package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;

import rs.ac.bg.etf.pp1.ast.*;

parser code {:

	boolean errorDetected = false;

	Logger log = Logger.getLogger(getClass());


    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke

    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }

    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }

    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
    	errorDetected = true;
    	StringBuilder msg = new StringBuilder(message);
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }

    public void report_info(String message, Object info) {
    	StringBuilder msg = new StringBuilder(message);
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.info(msg.toString());
    }

:}

scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null)
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}

terminal PROG, BREAK, ELSE, CONST, IF, NEW, PRINT, READ, RETURN, VOID, CONTINUE, FOR, NAMESPACE;
terminal PLUS, MINUS, MUL, DIV, MOD;
terminal EQUALSTO, DIFFERENT, GREATER, EGREATER, LESS, ELESS, AND, OR;
terminal EQUAL, PLUSPLUS, MINUSMINUS;
terminal SEMI, DOUBLEDOT, COMMA, LPAREN, RPAREN, LSQBRACE, RSQBRACE, LBRACE, RBRACE;
terminal LAMBDA, DOUBLECOLON;
terminal String BOOL;
terminal String CHAR;
terminal Integer NUMBER;
terminal String IDENT;

//nonterminal Namespace; // defined
nonterminal NamespaceMany;
//nonterminal Program; // defined
nonterminal ConstDeclOptMany;
nonterminal VarDeclOptMany;
nonterminal MethodDeclOptMany;
nonterminal ConstDecl;
nonterminal ConstDeclPart;
nonterminal VarDeclPart;
nonterminal VarDecl;
nonterminal VarDeclOpt;
nonterminal FormParsOptOne;
//nonterminal MethodDecl; // defined
nonterminal FormPars;
nonterminal OptActPars;
//nonterminal Type; // defined
nonterminal DesignatorStatementOpt;
nonterminal OptPrint;
nonterminal Statement;
nonterminal StatementMany;
//nonterminal Term; // defined
nonterminal DesignatorStatePart;
nonterminal DesignatorStatement;
nonterminal ActPars;
nonterminal Condition;
nonterminal CondTerm;
nonterminal CondFact;
//nonterminal Expr; // defined
nonterminal OptExpr;
nonterminal OptFactorParenPars;
//nonterminal ConstVal; // defined
//nonterminal Factor; // defined
//nonterminal Designator; // defined
nonterminal OptDesignatorPart;
nonterminal Label;
nonterminal Assignop;
nonterminal Relop;
nonterminal Addop;
nonterminal Mulop;

nonterminal rs.etf.pp1.symboltable.concepts.Struct Type;
nonterminal rs.etf.pp1.symboltable.concepts.Struct Term;
nonterminal rs.etf.pp1.symboltable.concepts.Struct Factor;
nonterminal rs.etf.pp1.symboltable.concepts.Struct ConstVal;
nonterminal rs.etf.pp1.symboltable.concepts.Struct Expr;

nonterminal rs.etf.pp1.symboltable.concepts.Obj Program;
nonterminal rs.etf.pp1.symboltable.concepts.Obj Namespace;
nonterminal rs.etf.pp1.symboltable.concepts.Obj MethodDecl;
nonterminal rs.etf.pp1.symboltable.concepts.Obj Designator;

nonterminal If;
nonterminal Else;

precedence left Else;
//precedence left ELSE;
//precedence left IF;

If					::= (If) IF;
Else 				::= (Else) ELSE;

Namespace 		    ::= (Namespace) NAMESPACE IDENT:namespaceName LBRACE ConstDeclOptMany VarDeclOptMany LBRACE MethodDeclOptMany RBRACE RBRACE;

NamespaceMany       ::= (NamespaceManyClass) NamespaceMany Namespace
                    |   (NamespaceManyEmptyClass) /* epsilon */;

// Done
Program 		    ::= (Program) PROG IDENT:programName NamespaceMany ConstDeclOptMany VarDeclOptMany LBRACE MethodDeclOptMany RBRACE;

ConstDeclOptMany    ::= (ConstDeclOptManyClass) ConstDeclOptMany ConstDecl
					|	(ConstDeclOptNoClass) /* epsilon */;

MethodDeclOptMany	::= (MethodDeclOptManyClass) MethodDeclOptMany MethodDecl
					|	(MethodDeclOptEmptyClass) /* epsilon */;

VarDeclPart         ::= (VarDeclOneClass) Type IDENT:name
                    |   error SEMI:l {: parser.report_error("Sintaksa greska deklaracije globalne promenljive na liniji " + lleft, null); :}
                    |	(VarDeclArrayClass) Type IDENT:name LSQBRACE RSQBRACE
                    |	(VarDeclManyOneClass) VarDeclPart COMMA IDENT:name
                    |	(VarDeclManyArrayClass) VarDeclPart COMMA IDENT:name LSQBRACE RSQBRACE;

ConstDecl           ::= (ConstDecl) CONST Type ConstDeclPart SEMI;

ConstDeclPart       ::= (ConstDeclPartManyClass) ConstDeclPart COMMA EQUAL ConstVal:value
                    |   (ConstDeclPartOneClass) IDENT:name EQUAL ConstVal:value;

VarDecl             ::= (VarDecl) VarDeclPart SEMI;

FormParsOptOne      ::= (FormParsOptOneClass) FormPars
                    |   (FormParsOptOneEmptyClass) /* epsilon */;

VarDeclOpt          ::= (VarDeclOptManyClass) VarDeclOpt VarDecl
                    |   (VarDeclOptEmptyClass) /* epsilon */;

MethodDecl          ::= (MethodDeclTypeClass) Type IDENT:methodName LPAREN FormParsOptOne RPAREN VarDeclOpt LBRACE StatementMany RBRACE
                    |   (MethodDeclVoidClass) VOID IDENT:methodName LPAREN FormParsOptOne RPAREN VarDeclOpt LBRACE StatementMany RBRACE;

FormPars            ::= (FormParsOneClass) Type IDENT:name
                    |	(FormParsArrayClass) Type IDENT:name LSQBRACE RSQBRACE
                    |	(FormParsManyOneClass) FormPars COMMA Type IDENT:name
                    |	(FormParsManyArrayClass) FormPars COMMA Type IDENT:name LSQBRACE RSQBRACE;

Type                ::= (TypeNamespaceClass) IDENT:namespace DOUBLECOLON IDENT:type
                    |	(TypeClass) IDENT:type;

StatementMany       ::= (StatementManyManyClass) StatementMany Statement
                    |   (StatementEmptyClass) /* epsilon */;

OptExpr				::= (OptExprOneClass) Expr
					| 	(OptExprEmptyClass);

Statement           ::= (StatementDesignatorClass) DesignatorStatement SEMI
                    |   (StatementIfClass) If LPAREN Condition RPAREN Statement
                    |   (StatementIfElseClass) If LPAREN Condition RPAREN Statement Else Statement
                    |   (StatementBreakClass) BREAK SEMI
                    |   (StatementContinueClass) CONTINUE SEMI
                    |   (StatementReturnClass) RETURN OptExpr SEMI
                    |   (StatementReadClass) READ LPAREN Designator RPAREN SEMI
                    |   (StatementPrintClass) PRINT LPAREN Expr OptPrint RPAREN SEMI
                    |   (StatementForClass) FOR LPAREN DesignatorStatementOpt SEMI CondFact SEMI DesignatorStatementOpt RPAREN
                    |   (StatementForConditonClass) FOR LPAREN DesignatorStatementOpt SEMI SEMI DesignatorStatementOpt RPAREN
                    |   (StatementManyClass) LBRACE StatementMany RBRACE;

OptPrint	        ::= (OptPrintOneClass) COMMA NUMBER
					|	(OptPrintEmptyClass) /* epsilon */;

DesignatorStatePart ::= (DesignatorStatePartManyClass) DesignatorStatePart Designator COMMA
                    |   (DesignatorStatePartOneClass) DesignatorStatePart COMMA
                    |   (DesignatorStatePartEmptyClass) /* epsilon */;

DesignatorStatement ::= (DesignatorStatementAssignClass) Designator Assignop Expr
                    |   (DesignatorStatementNoParamsClass) Designator LPAREN RPAREN
                    |   (DesignatorStatementParamsClass) Designator LPAREN ActPars RPAREN
                    |   (DesignatorStatementPlusClass) Designator PLUSPLUS
                    |   (DesignatorStatementMinusClass) Designator MINUSMINUS
                    |   (DesignatorStatementManyClass) LSQBRACE DesignatorStatePart MUL Designator RSQBRACE Assignop Designator;

// Done
ActPars             ::= (ActParsManyClass) ActPars COMMA Expr
                    |   (ActParsOneClass) Expr;

Condition           ::= (ConditionManyClass) Condition OR CondTerm
                    |   (ConditionOneClass) CondTerm;

CondTerm            ::= (CondTermManyClass) CondTerm AND CondFact
                    |   (CondTermOneClass) CondFact;

CondFact            ::= (CondFactManyClass) Expr Relop Expr
                    |   (CondFactOneClass) Expr;

Expr                ::= (ExprManyClass) Expr Addop Term
                    |   (ExprNegativeOneClass) MINUS Term
                    |   (ExprOneClass) Term;

Term                ::= (TermManyClass) Term Mulop Factor
                    |   (TermOneClass) Factor;

// Done
ConstVal 			::= (ConstValNumClass) NUMBER
					|	(ConstValCharClass) CHAR
					|	(ConstValBooCllass) BOOL;

Factor              ::= (FactorParenParsClass) Designator OptFactorParenPars // Done
                    |   (FactorConstValClass) ConstVal
                    |   (FactorNewTypeExprClass) NEW Type LSQBRACE Expr RSQBRACE
                    |   (FactorNewTypeWithParamsClass) NEW Type LPAREN OptActPars RPAREN
                    |   (FactorParenExprClass) LPAREN Expr RPAREN;

OptFactorParenPars  ::= (OptFactorParenParsClass) LPAREN ActPars RPAREN
                    |   (OptFactorParenClass) LPAREN RPAREN
                    |   (OptFactorEmptyClass) /* epsilon */;

OptActPars          ::= (OptActParsOneClass) ActPars
                    |   (OptActParsEmptyClass) /* epsilon */;

Designator          ::= (Designator) Type IDENT:name OptDesignatorPart;

OptDesignatorPart   ::= (OptDesignatorPartClass) LSQBRACE Expr RSQBRACE
                    |   (OptDesignatorPartEmptyClass) /* epsilon */;

Label               ::= (Label) IDENT:name;

Assignop		    ::= (Assignop) EQUAL
                    |	error SEMI:l {: parser.report_error("Sintaksa greska konstrukcije iskaza dodele na liniji " + lleft, null); :};

Relop				::= (RelopEqualstoClass) EQUALSTO
					|	(RelopDifferentClass) DIFFERENT
					|	(RelopLessClass) LESS
					|	(RelopElessClass) ELESS
					|	(RelopGreaterClass) GREATER
					|	(RelopEgreaterClass) EGREATER;

Addop				::= (AddopPlusClass) PLUS
					|	(AddopMinusClass) MINUS;

Mulop				::= (MulopMulClass) MUL
					| 	(MulopDivClass) DIV
					|	(MulopModClass) MOD;
