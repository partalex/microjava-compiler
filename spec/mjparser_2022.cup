package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;

import rs.ac.bg.etf.pp1.ast.*;

parser code {:

	boolean errorDetected = false;

	Logger log = Logger.getLogger(getClass());


    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke

    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }

    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }

    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
    	errorDetected = true;
    	StringBuilder msg = new StringBuilder(message);
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }

    public void report_info(String message, Object info) {
    	StringBuilder msg = new StringBuilder(message);
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.info(msg.toString());
    }

:}

scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null)
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}

terminal PLUS, MINUS, MUL, DIV, MOD, EQUAL, PLUSPLUS, MINUSMINUS, FOREACH, LAMBDA;
terminal SEMI, COMMA, DOT, LPAREN, RPAREN, LBRACE, RBRACE, LSQBRACE, RSQBRACE, DOUBLEDOT;
terminal PROG, BREAK, CONST, IF, FOR, NEW, ELSE, PRINT, READ, RETURN, VOID, CONTINUE;
terminal EQUALSTO, DIFFERENT, GREATER, EGREATER, LESS, ELESS, AND, OR;
terminal Integer NUMBER;
terminal String IDENT;
terminal String BOOL;
terminal String CHAR;

// finished
nonterminal Program;
nonterminal ConstVal;
nonterminal OptionalArray;
nonterminal Type;
nonterminal VarDecl;
nonterminal Assignop;
nonterminal Relop;
nonterminal Addop;
nonterminal Mulop;
nonterminal FormPars;
nonterminal ActPars;
nonterminal Condition;
nonterminal CondFact;
nonterminal Term;
nonterminal Expr;
nonterminal CondTerm;
nonterminal Designator;
nonterminal Factor;
nonterminal MethodDecl;
nonterminal DesignatorStFirst;
nonterminal DesignatorStSec;
nonterminal DesignatorStatement;
nonterminal if;
nonterminal else;
nonterminal ConstDeclPart;
nonterminal ConstDecl;
nonterminal Statement;
nonterminal VarDeclOpt;
nonterminal MethodDeclOptMany;
nonterminal AddopTermMany;
nonterminal Label;
nonterminal DesignatorPart;
nonterminal StatementOptMany;
nonterminal VarDeclPartMany;
nonterminal FormParsPart;
nonterminal FormParsOptOne;
nonterminal ConstDeclOptMany;
nonterminal VarDeclOptMany;
nonterminal StatementIf;
nonterminal StatementIfElse;

precedence left ELSE;
precedence left IF;

// TODO - new
Program 		    ::= (ProgramClass) PROG IDENT:program ConstDeclOptMany VarDeclOptMany LBRACE MethodDeclOptMany RBRACE;

ConstDeclOptMany    ::= (ConstDeclOptManyClass) ConstDeclOptMany ConstDecl
					|	(ConstDeclOptNoClass) /* epsilon */;

VarDeclOptMany      ::= (VarDeclOptManyClass) VarDeclOptMany VarDecl
					|	(VarDeclOptManyClass) /* epsilon */;

MethodDeclOptMany	::= (MethodDeclOptManyClass) MethodDeclOptMany MethodDecl
					|	(MethodDeclOptManyNoClass) /* epsilon */;

ConstVal 			::= (NumConstClass) NUMBER
					|	(CharConstClass) CHAR
					|	(BoolConstClass) BOOL;

OptionalArray	    ::= (ArrayClass) LSQBRACE RSQBRACE
				    |   (NoArrayClass) /* epsilon */;

Type                ::= (TypeClass) IDENT:type;

VarDeclPartMany     ::= (VarDeclPartClass) VarDeclPartMany COMMA IDENT:name OptionalArray
                    |   (VarDeclPartNoClass) /* epsilon */;

VarDecl             ::= (ManyVarDeclClass) Type IDENT:name OptionalArray VarDeclPartMany;

Assignop		    ::= (EqualClass) EQUAL;

Relop				::= (EqualstoClass) EQUALSTO
					|	(DifferentClass) DIFFERENT
					|	(LessClass) LESS
					|	(ElessClass) ELESS
					|	(GreaterClass) GREATER
					|	(EgreaterClass) EGREATER;

Addop				::= (PlusClass) PLUS
					|	(MinusClass) MINUS;

Mulop				::= (MulClass) MUL
					| 	(DivClass) DIV
					|	(ModClass) MOD;

FormParsPart        ::= (FormParsPartClass) FormParsPart COMMA Type IDENT:name OptionalArray
					|	(FormParsPartNoClass) /* epsilon */;

FormPars            ::= (ManyFormParsClass) FormPars Type IDENT:name OptionalArray;

ActPars             ::= (ManyActPars) ActPars COMMA Expr
                    |   (OneActPars) Expr;

Condition           ::= (ManyConditionClass) Condition OR CondTerm
                    |   (OneConditionClass) CondTerm;

CondFact            ::= (TwoCondFactClass) Expr Relop Expr
                    |   (OneCondFactClass) Expr;

CondTerm            ::= (ManyCondTermClass) CondTerm AND CondFact
                    |   (OneCondTermClass) CondFact;

Term                ::= (ManyTermClass) Term Mulop Factor
                    |   (OneTermClass) Factor;

AddopTermMany       ::= (AddopTermOptClass) AddopTermMany Addop Term
                    |   (AddopTermOptNoClass) /* epsilon */;

Expr                ::= (ManyMinusExprClass) MINUS Term AddopTermMany
                    |   (ManyExprClass) Term AddopTermMany;

DesignatorPart      ::= (DesignatorPartClass) DesignatorPart DOT IDENT
                    |   (DesignatorPartClass) DesignatorPart LSQBRACE Expr RSQBRACE
                    |   (DesignatorPartClass) /* epsilon */;

Designator          ::= (ManyDesignatorClass) IDENT DesignatorPart;

Factor              ::= (FactorParenParsClass) Designator LPAREN ActPars RPAREN
                    |   (FactorParenClass) Designator LPAREN RPAREN
                    |   (FactorClass) Designator
                    |   (FactorConstValClass) ConstVal
                    |   (FactorNewTypeBraceClass) NEW Type LSQBRACE Expr RSQBRACE
                    |   (FactorNewTypeParenClass) NEW Type LPAREN ActPars RPAREN
                    |   (FactorNewTypeParenClass) NEW Type LPAREN RPAREN
                    |   (FactorParenExprClass) LPAREN Expr RPAREN;

StatementOptMany    ::= (StatementOptClass) StatementOptMany Statement
                    |   (StatementOptNoClass) /* epsilon */;

FormParsOptOne      ::= (FormParsOptOneClass) FormPars
                    |   (FormParsOptOneNoClass) /* epsilon */;

VarDeclOpt          ::= (VarDeclOptClass) VarDeclOpt VarDecl
                    |   (VarDeclOptNoClass) /* epsilon */;

MethodDecl          ::= (MethodDeclTypeClass) Type IDENT LPAREN FormParsOptOne RPAREN VarDeclOpt LBRACE StatementOptMany RBRACE
                    |   (MethodDeclVoidClass) VOID IDENT LPAREN FormParsOptOne RPAREN VarDeclOpt LBRACE StatementOptMany RBRACE;

DesignatorStatement ::= (DesignatorStFirstClass) Designator Assignop Expr
                    |   (DesignatorStFirstClass) Designator LPAREN RPAREN
                    |   (DesignatorStFirstClass) Designator LPAREN ActPars RPAREN
                    |   (DesignatorStFirstClass) Designator PLUSPLUS
                    |   (DesignatorStFirstClass) Designator MINUSMINUS;

if					::= (IfClass) IF;

else 				::= (ElseClass) ELSE;

ConstDecl           ::= (ConstDeclClass) CONST Type ConstDeclPart SEMI;

ConstDeclPart       ::= (ManyConstDeclPartClass) IDENT:name EQUAL ConstVal:value COMMA ConstDeclPart
                    |   (OneConstDeclPartClass) IDENT:name EQUAL ConstVal:value;

Label               ::= (LabelClass) IDENT:name;

StatementIf         ::= if LPAREN Condition RPAREN Statement;

StatementIfElse     ::= if LPAREN Condition RPAREN Statement else Statement;
// TODO - Review start      --------------------------------------------------------------------------------------------
// TODO - Review end        --------------------------------------------------------------------------------------------
// TODO - Conflict start    --------------------------------------------------------------------------------------------

Statement           ::= (StatementDesignatorClass) DesignatorStatement SEMI
                    |   (StatementIfClass) StatementIf
                    |   (StatementIfClass) StatementIfElse
                    |   (StatementBreakClass) BREAK SEMI
                    |   (StatementContinueClass) CONTINUE SEMI
                    |   (StatementExprClass) RETURN Expr SEMI
                    |   (StatementReturnClass) RETURN SEMI
                    |   (StatementReadClass) READ LPAREN Designator RPAREN SEMI
                    |   (StatementPrintManyExprClass) PRINT LPAREN Expr COMMA NUMBER RPAREN SEMI
                    |   (StatementPrintOneExprClass) PRINT LPAREN Expr RPAREN SEMI
                    |   (StatementManyClass) LBRACE StatementOptMany RBRACE
//                    |   (StatementWhileClass) FOR LPAREN Condition RPAREN Statement
                    ;


// TODO - Conflict end  ------------------------------------------------------------------------------------------------
