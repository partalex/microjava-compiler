package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;

import rs.ac.bg.etf.pp1.ast.*;

parser code {:

	boolean errorDetected = false;

	Logger log = Logger.getLogger(getClass());


    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke

    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }

    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }

    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
    	errorDetected = true;
    	StringBuilder msg = new StringBuilder(message);
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }

    public void report_info(String message, Object info) {
    	StringBuilder msg = new StringBuilder(message);
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.info(msg.toString());
    }

:}

scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null)
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}

terminal PROG, BREAK, ELSE, CONST, IF, NEW, PRINT, READ, RETURN, VOID, CONTINUE, FOR, NAMESPACE;
terminal PLUS, MINUS, MUL, DIV, MOD;
terminal EQUALSTO, DIFFERENT, GREATER, EGREATER, LESS, ELESS, AND, OR;
terminal EQUAL, PLUSPLUS, MINUSMINUS;
terminal SEMI, DOUBLEDOT, COMMA, LPAREN, RPAREN, LSQBRACE, RSQBRACE, LBRACE, RBRACE;
terminal LAMBDA, DOUBLECOLON;
terminal String BOOL;
terminal String CHAR;
terminal Integer NUMBER;
terminal String IDENT;

nonterminal NamespaceMany NamespaceMany;
nonterminal ConstDeclOptMany ConstDeclOptMany;
nonterminal VarDeclOptMany VarDeclOptMany;
nonterminal MethodDeclOptMany MethodDeclOptMany;
nonterminal ConstDecl ConstDecl;
nonterminal ConstList ConstList;
nonterminal VarDecl VarDecl;
nonterminal VarDeclOpt VarDeclOpt;
nonterminal FormParsOptOne FormParsOptOne;
nonterminal FormPars FormPars;
nonterminal OptMinus OptMinus;
nonterminal OptActPars OptActPars;
nonterminal DesignatorStatementOpt DesignatorStatementOpt;
nonterminal OptPrint OptPrint;
nonterminal Statement Statement;
nonterminal StatementMany StatementMany;
nonterminal DesignatorStatePart DesignatorStatePart;
nonterminal DesignatorStatement DesignatorStatement;
nonterminal ActPars ActPars;
nonterminal ActPartsOptional ActPartsOptional;
nonterminal OptionalArray OptionalArray;
nonterminal OptExpr OptExpr;
nonterminal OptFactorParenPars OptFactorParenPars;
nonterminal Label Label;
nonterminal Assignop Assignop;
nonterminal Relop Relop;
nonterminal Addop Addop;
nonterminal Mulop Mulop;
nonterminal VarDeclList VarDeclList;
nonterminal FormParsList FormParsList;
nonterminal ConditionStatement ConditionStatement;
nonterminal For For;
nonterminal StartOfCondition StartOfCondition;
nonterminal EndOfCondition EndOfCondition;
nonterminal EndFor EndFor;
nonterminal EndOfGlobal EndOfGlobal;

nonterminal rs.etf.pp1.symboltable.concepts.Struct Type;
nonterminal rs.etf.pp1.symboltable.concepts.Struct Term;
nonterminal rs.etf.pp1.symboltable.concepts.Struct Factor;
nonterminal rs.etf.pp1.symboltable.concepts.Struct MethodType;
nonterminal rs.etf.pp1.symboltable.concepts.Struct ConstVal;
nonterminal rs.etf.pp1.symboltable.concepts.Struct Expr;
nonterminal rs.etf.pp1.symboltable.concepts.Struct Condition;
nonterminal rs.etf.pp1.symboltable.concepts.Struct CondTerm;
nonterminal rs.etf.pp1.symboltable.concepts.Struct CondFact;
nonterminal rs.etf.pp1.symboltable.concepts.Struct AddTerm;
nonterminal rs.etf.pp1.symboltable.concepts.Struct CondFactOptional;

nonterminal rs.etf.pp1.symboltable.concepts.Obj Program;
nonterminal rs.etf.pp1.symboltable.concepts.Obj ProgramName;
nonterminal rs.etf.pp1.symboltable.concepts.Obj Namespace;
nonterminal rs.etf.pp1.symboltable.concepts.Obj NamespaceName;
nonterminal rs.etf.pp1.symboltable.concepts.Obj OptNamespace;
nonterminal rs.etf.pp1.symboltable.concepts.Obj MethodTypeName;
nonterminal rs.etf.pp1.symboltable.concepts.Obj MethodDecl;
nonterminal rs.etf.pp1.symboltable.concepts.Obj Designator;
nonterminal rs.etf.pp1.symboltable.concepts.Obj DesignatorName;
nonterminal rs.etf.pp1.symboltable.concepts.Obj OptDesignatorPart;
nonterminal rs.etf.pp1.symboltable.concepts.Obj DesigPart;
nonterminal rs.etf.pp1.symboltable.concepts.Obj ConstDeclPart;
nonterminal rs.etf.pp1.symboltable.concepts.Obj VarDeclPart;


nonterminal If If;
nonterminal Else Else;

//precedence left Else;
precedence left ELSE;
//precedence left IF;

// Done
Program 		    ::= (Program) PROG ProgramName:P1 NamespaceMany:N2 ConstDeclOptMany:C3 VarDeclOpt:V4 EndOfGlobal:E5 MethodDeclOptMany:M6 RBRACE {: RESULT=new Program(P1, N2, C3, V4, E5, M6); RESULT.setLine(P1left); :};

EndOfGlobal		    ::= (EndOfGlobal) LBRACE {: RESULT=new EndOfGlobal(); :};

ProgramName		    ::= (ProgramName) IDENT:programName {: RESULT=new ProgramName(programName); RESULT.setLine(programNameleft); :};

Namespace 		    ::= (Namespace) NAMESPACE NamespaceName:N1 LBRACE ConstDeclOptMany:C2 VarDeclOpt:V3 LBRACE MethodDeclOptMany:M4 RBRACE RBRACE {: RESULT=new Namespace(N1, C2, V3, M4); RESULT.setLine(N1left); :};

NamespaceName 		::= (NamespaceName) IDENT:namespaceName {: RESULT=new NamespaceName(namespaceName); RESULT.setLine(namespaceNameleft); :};

NamespaceMany       ::= (NamespaceManyClass) NamespaceMany:N1 Namespace:N2 {: RESULT=new NamespaceManyClass(N1, N2); RESULT.setLine(N1left); :}
                    |   (NamespaceManyEmptyClass) {: RESULT=new NamespaceManyEmptyClass(); :} /* epsilon */;
// Done
MethodDeclOptMany	::= (MethodDeclOptManyClass) MethodDeclOptMany:M1 MethodDecl:M2 {: RESULT=new MethodDeclOptManyClass(M1, M2); RESULT.setLine(M1left); :}
					|	(MethodDeclOptEmptyClass) {: RESULT=new MethodDeclOptEmptyClass(); :} /* epsilon */;
// Done
OptionalArray		::= (OptionalArrayClass) LSQBRACE RSQBRACE {: RESULT=new OptionalArrayClass(); :}
					|	(OptionalArrayEmptyClass) {: RESULT=new OptionalArrayEmptyClass(); :} /* epsilon */;

// Done
VarDeclPart         ::= (VarDeclPart) IDENT:name OptionalArray:O1 {: RESULT=new VarDeclPart(name, O1); RESULT.setLine(nameleft); :};

// Done
VarDeclList         ::= (VarDeclListManyClass) VarDeclList:V1 COMMA VarDeclPart:V2 {: RESULT=new VarDeclListManyClass(V1, V2); RESULT.setLine(V1left); :}
                    |	(VarDeclListOneClass) VarDeclPart:V1 {: RESULT=new VarDeclListOneClass(V1); RESULT.setLine(V1left); :}
                    |   error SEMI:l {: parser.report_error("Sintaksa greska deklaracije globalne promenljive na liniji " + lleft, null); :} {: RESULT=new VarDeclListDerived1(); :};

// Done
ConstDeclOptMany    ::= (ConstDeclOptManyClass) ConstDeclOptMany:C1 ConstDecl:C2 {: RESULT=new ConstDeclOptManyClass(C1, C2); RESULT.setLine(C1left); :}
					|	(ConstDeclOptNoClass) {: RESULT=new ConstDeclOptNoClass(); :} /* epsilon */;
// Done
ConstDecl           ::= (ConstDecl) CONST Type:T1 ConstDeclPart:C2 SEMI {: RESULT=new ConstDecl(T1, C2); RESULT.setLine(T1left); :};

// Done
ConstDeclPart       ::= (ConstDeclPart) IDENT:name EQUAL ConstVal:value {: RESULT=new ConstDeclPart(name, value); RESULT.setLine(nameleft); :};

// Done
ConstList           ::= (ConstListManyClass) ConstList:C1 COMMA ConstDeclPart:C2 {: RESULT=new ConstListManyClass(C1, C2); RESULT.setLine(C1left); :}
                    |   (ConstListOneClass) ConstDeclPart:C1 {: RESULT=new ConstListOneClass(C1); RESULT.setLine(C1left); :};

// Done
VarDecl             ::= (VarDecl) Type:T1 VarDeclList:V2 SEMI {: RESULT=new VarDecl(T1, V2); RESULT.setLine(T1left); :};

// Done
VarDeclOpt          ::= (VarDeclOptManyClass) VarDeclOpt:V1 VarDecl:V2 {: RESULT=new VarDeclOptManyClass(V1, V2); RESULT.setLine(V1left); :}
                    |   (VarDeclOptEmptyClass) {: RESULT=new VarDeclOptEmptyClass(); :} /* epsilon */;

// Done
MethodType			::= (MethodTypeVoidClass) VOID {: RESULT=new MethodTypeVoidClass(); :}
					|	(MethodTypeVoidClassType) Type:T1 {: RESULT=new MethodTypeVoidClassType(T1); RESULT.setLine(T1left); :};

// Done
MethodTypeName		::= (MethodTypeName) MethodType:M1 IDENT:methodName {: RESULT=new MethodTypeName(M1, methodName); RESULT.setLine(M1left); :};

// Done
MethodDecl          ::= (MethodDecl) MethodTypeName:M1 LPAREN FormParsOptOne:F2 RPAREN VarDeclOpt:V3 LBRACE StatementMany:S4 RBRACE {: RESULT=new MethodDecl(M1, F2, V3, S4); RESULT.setLine(M1left); :};

// Done
FormParsOptOne      ::= (FormParsOptOneClass) FormParsList:F1 {: RESULT=new FormParsOptOneClass(F1); RESULT.setLine(F1left); :}
                    |   (FormParsOptOneEmptyClass) {: RESULT=new FormParsOptOneEmptyClass(); :} /* epsilon */;

// Done
FormParsList        ::= (FormParsListManyClass) FormParsList:F1 COMMA FormPars:F2 {: RESULT=new FormParsListManyClass(F1, F2); RESULT.setLine(F1left); :}
                    |   (FormParsListOneClass) FormPars:F1 {: RESULT=new FormParsListOneClass(F1); RESULT.setLine(F1left); :};

// Done
FormPars            ::= (FormPars) Type:T1 IDENT:name OptionalArray:O2 {: RESULT=new FormPars(T1, name, O2); RESULT.setLine(T1left); :};

// Done
Type                ::= (TypeNamespaceClass) IDENT:namespace DOUBLECOLON {: RESULT=new TypeNamespaceClass(namespace); RESULT.setLine(namespaceleft); :}
                    |	(TypeClass) IDENT:typeName {: RESULT=new TypeClass(typeName); RESULT.setLine(typeNameleft); :};

// Done
StatementMany       ::= (StatementManyManyClass) StatementMany:S1 Statement:S2 {: RESULT=new StatementManyManyClass(S1, S2); RESULT.setLine(S1left); :}
                    |   (StatementEmptyClass) {: RESULT=new StatementEmptyClass(); :} /* epsilon */;

// Done
OptExpr				::= (OptExprOneClass) Expr:E1 {: RESULT=new OptExprOneClass(E1); RESULT.setLine(E1left); :}
					| 	(OptExprEmptyClass) {: RESULT=new OptExprEmptyClass(); :};

Statement           ::= (StatementDesignatorClass) DesignatorStatement:D1 SEMI {: RESULT=new StatementDesignatorClass(D1); RESULT.setLine(D1left); :}
                    |   (StatementIfClass) If:I1 ConditionStatement:C2 Statement:S3 {: RESULT=new StatementIfClass(I1, C2, S3); RESULT.setLine(I1left); :}
                    |   (StatementIfElseClass) If:I1 ConditionStatement:C2 Statement:S3 Else:E4 Statement:S5 {: RESULT=new StatementIfElseClass(I1, C2, S3, E4, S5); RESULT.setLine(I1left); :}
                    |   (StatementBreakClass) BREAK SEMI {: RESULT=new StatementBreakClass(); :} // Done
                    |   (StatementContinueClass) CONTINUE SEMI {: RESULT=new StatementContinueClass(); :} // Done
                    |   (StatementReturnClass) RETURN OptExpr:O1 SEMI {: RESULT=new StatementReturnClass(O1); RESULT.setLine(O1left); :} // Done
                    |   (StatementReadClass) READ LPAREN Designator:D1 RPAREN SEMI {: RESULT=new StatementReadClass(D1); RESULT.setLine(D1left); :}
                    |   (StatementPrintClass) PRINT LPAREN Expr:E1 OptPrint:O2 RPAREN SEMI {: RESULT=new StatementPrintClass(E1, O2); RESULT.setLine(E1left); :} // Done
                    |   (StatementForClass) For:F1 LPAREN DesignatorStatementOpt:D2 StartOfCondition:S3 CondFactOptional:C4 SEMI DesignatorStatementOpt:D5 EndOfCondition:E6 Statement:S7 EndFor:E8 {: RESULT=new StatementForClass(F1, D2, S3, C4, D5, E6, S7, E8); RESULT.setLine(F1left); :} // Done
                    |   (StatementManyClass) LBRACE StatementMany:S1 RBRACE {: RESULT=new StatementManyClass(S1); RESULT.setLine(S1left); :}; // Done

EndFor                      ::= (EndFor) {: RESULT=new EndFor(); :} /* epsilon */;

ConditionStatement          ::= (ConditionStatement) LPAREN Condition:C1 RPAREN {: RESULT=new ConditionStatement(C1); RESULT.setLine(C1left); :};

EndOfCondition              ::= (EndOfCondition) RPAREN {: RESULT=new EndOfCondition(); :};

DesignatorStatementOpt      ::= (DesignatorStatementOptManyClass) DesignatorStatementOpt:D1 COMMA DesignatorStatement:D2 {: RESULT=new DesignatorStatementOptManyClass(D1, D2); RESULT.setLine(D1left); :}
                            |	  (DesignatorStatementOptOneClass) DesignatorStatement:D1 {: RESULT=new DesignatorStatementOptOneClass(D1); RESULT.setLine(D1left); :}
                            |	  (DesignatorStatementOptEmptyClass) {: RESULT=new DesignatorStatementOptEmptyClass(); :} /* epsilon */;

If					::= (If) IF {: RESULT=new If(); :};
Else 				::= (Else) ELSE {: RESULT=new Else(); :};
For 				::= (For) FOR {: RESULT=new For(); :};

StartOfCondition 	::= (StartOfCondition) SEMI {: RESULT=new StartOfCondition(); :};

CondFactOptional    ::= (CondFactOptionalOneClass) CondFact:C1 {: RESULT=new CondFactOptionalOneClass(C1); RESULT.setLine(C1left); :}
                    |	(CondFactOptionalEmptyClass) {: RESULT=new CondFactOptionalEmptyClass(); :} /* epsilon */;

// Done
OptPrint	        ::= (OptPrintOneClass) COMMA NUMBER:N1 {: RESULT=new OptPrintOneClass(N1); RESULT.setLine(N1left); :}
					|	(OptPrintEmptyClass) {: RESULT=new OptPrintEmptyClass(); :} /* epsilon */;

// Done
DesignatorStatePart ::= (DesignatorStatePartManyClass) DesignatorStatePart:D1 Designator:D2 COMMA {: RESULT=new DesignatorStatePartManyClass(D1, D2); RESULT.setLine(D1left); :}
                    |   (DesignatorStatePartOneClass) DesignatorStatePart:D1 COMMA {: RESULT=new DesignatorStatePartOneClass(D1); RESULT.setLine(D1left); :}
                    |   (DesignatorStatePartEmptyClass) {: RESULT=new DesignatorStatePartEmptyClass(); :} /* epsilon */;

DesignatorStatement ::= (DesignatorStatementAssignClass) Designator:D1 Assignop:A2 Expr:E3 {: RESULT=new DesignatorStatementAssignClass(D1, A2, E3); RESULT.setLine(D1left); :} // Done
                    |   (DesignatorStatementParamsClass) Designator:D1 LPAREN ActPartsOptional:A2 RPAREN {: RESULT=new DesignatorStatementParamsClass(D1, A2); RESULT.setLine(D1left); :} //
                    |   (DesignatorStatementPlusClass) Designator:D1 PLUSPLUS {: RESULT=new DesignatorStatementPlusClass(D1); RESULT.setLine(D1left); :} // Done
                    |   (DesignatorStatementMinusClass) Designator:D1 MINUSMINUS {: RESULT=new DesignatorStatementMinusClass(D1); RESULT.setLine(D1left); :} // Done
                    |   (DesignatorStatementManyClass) LSQBRACE DesignatorStatePart:D1 MUL Designator:D2 RSQBRACE Assignop:A3 Designator:D4 {: RESULT=new DesignatorStatementManyClass(D1, D2, A3, D4); RESULT.setLine(D1left); :};

// Done
ActPartsOptional	::= (ActPartsOptionalOneClass) ActPars:A1 {: RESULT=new ActPartsOptionalOneClass(A1); RESULT.setLine(A1left); :}
					|	(ActPartsOptionalEmptyClass) {: RESULT=new ActPartsOptionalEmptyClass(); :} /* epsilon */;

// Done
ActPars             ::= (ActParsManyClass) ActPars:A1 COMMA Expr:E2 {: RESULT=new ActParsManyClass(A1, E2); RESULT.setLine(A1left); :}
                    |   (ActParsOneClass) Expr:E1 {: RESULT=new ActParsOneClass(E1); RESULT.setLine(E1left); :};

// Done
Condition           ::= (ConditionManyClass) Condition:C1 OR CondTerm:C2 {: RESULT=new ConditionManyClass(C1, C2); RESULT.setLine(C1left); :}
                    |   (ConditionOneClass) CondTerm:C1 {: RESULT=new ConditionOneClass(C1); RESULT.setLine(C1left); :};

// Done
CondTerm            ::= (CondTermManyClass) CondTerm:C1 AND CondFact:C2 {: RESULT=new CondTermManyClass(C1, C2); RESULT.setLine(C1left); :}
                    |   (CondTermOneClass) CondFact:C1 {: RESULT=new CondTermOneClass(C1); RESULT.setLine(C1left); :};

// Done
CondFact            ::= (CondFactManyClass) Expr:E1 Relop:R2 Expr:E3 {: RESULT=new CondFactManyClass(E1, R2, E3); RESULT.setLine(E1left); :}
                    |   (CondFactOneClass) Expr:E1 {: RESULT=new CondFactOneClass(E1); RESULT.setLine(E1left); :};

// Done
AddTerm				::= (AddTermManyClass) AddTerm:A1 Addop:A2 Term:T3 {: RESULT=new AddTermManyClass(A1, A2, T3); RESULT.setLine(A1left); :}
					|	(AddTermEmptyClass) {: RESULT=new AddTermEmptyClass(); :} /* epsilon */;

// Done
Expr                ::= (Expr) OptMinus:O1 Term:T2 AddTerm:A3 {: RESULT=new Expr(O1, T2, A3); RESULT.setLine(O1left); :};

// Done
OptMinus 			::= (OptMin) MINUS {: RESULT=new OptMin(); :}
					|	(NoMinus) {: RESULT=new NoMinus(); :} /* epsilon */;

// Done
Term                ::= (TermManyClass) Term:T1 Mulop:M2 Factor:F3 {: RESULT=new TermManyClass(T1, M2, F3); RESULT.setLine(T1left); :}
                    |   (TermOneClass) Factor:F1 {: RESULT=new TermOneClass(F1); RESULT.setLine(F1left); :};

// Done
ConstVal 			::= (ConstValNumClass) NUMBER:N1 {: RESULT=new ConstValNumClass(N1); RESULT.setLine(N1left); :}
					|	(ConstValCharClass) CHAR:C1 {: RESULT=new ConstValCharClass(C1); RESULT.setLine(C1left); :}
					|	(ConstValBooCllass) BOOL:B1 {: RESULT=new ConstValBooCllass(B1); RESULT.setLine(B1left); :};

// Done
Factor              ::= (FactorParenParsClass) Designator:D1 OptFactorParenPars:O2 {: RESULT=new FactorParenParsClass(D1, O2); RESULT.setLine(D1left); :}
                    |   (FactorConstValClass) ConstVal:C1 {: RESULT=new FactorConstValClass(C1); RESULT.setLine(C1left); :}
                    |   (FactorNewTypeExprClass) NEW Type:T1 LSQBRACE Expr:E2 RSQBRACE {: RESULT=new FactorNewTypeExprClass(T1, E2); RESULT.setLine(T1left); :}
                    |   (FactorParenExprClass) LPAREN Expr:E1 RPAREN {: RESULT=new FactorParenExprClass(E1); RESULT.setLine(E1left); :};

// Done
OptFactorParenPars  ::= (OptFactorParenParsClass) LPAREN OptActPars:O1 RPAREN {: RESULT=new OptFactorParenParsClass(O1); RESULT.setLine(O1left); :}
                    |   (OptFactorEmptyClass) {: RESULT=new OptFactorEmptyClass(); :} /* epsilon */;

// Done
OptActPars          ::= (OptActParsOneClass) ActPars:A1 {: RESULT=new OptActParsOneClass(A1); RESULT.setLine(A1left); :}
                    |   (OptActParsEmptyClass) {: RESULT=new OptActParsEmptyClass(); :} /* epsilon */;

OptNamespace          ::= (OptNamespaceClass) IDENT:namespace DOUBLECOLON DesignatorName:D1 {: RESULT=new OptNamespaceClass(namespace, D1); RESULT.setLine(namespaceleft); :}
                      |   (OptNamespaceEmptyClass) DesignatorName:D1 {: RESULT=new OptNamespaceEmptyClass(D1); RESULT.setLine(D1left); :};

// Done
Designator          ::= (Designator) OptNamespace:O1 OptDesignatorPart:O2 {: RESULT=new Designator(O1, O2); RESULT.setLine(O1left); :};

// Done
DesignatorName      ::= (DesignatorName) IDENT:designatorName {: RESULT=new DesignatorName(designatorName); RESULT.setLine(designatorNameleft); :};

// Done
OptDesignatorPart   ::= (OptDesignatorPartManyClass) OptDesignatorPart:O1 DesigPart:D2 {: RESULT=new OptDesignatorPartManyClass(O1, D2); RESULT.setLine(O1left); :}
                    |   (OptDesignatorPartEmptyClass) {: RESULT=new OptDesignatorPartEmptyClass(); :} /* epsilon */;

// Done
DesigPart			::= (DesigPart) LSQBRACE Expr:E1 RSQBRACE {: RESULT=new DesigPart(E1); RESULT.setLine(E1left); :};

//Done
Label               ::= (Label) IDENT:name {: RESULT=new Label(name); RESULT.setLine(nameleft); :};

//Done
Assignop		    ::= (Assignop) EQUAL {: RESULT=new Assignop(); :}
                    |	error SEMI:l {: parser.report_error("Sintaksa greska konstrukcije iskaza dodele na liniji " + lleft, null); :} {: RESULT=new AssignopDerived1(); :};

//Done
Relop				::= (RelopEqualstoClass) EQUALSTO {: RESULT=new RelopEqualstoClass(); :}
					|	(RelopDifferentClass) DIFFERENT {: RESULT=new RelopDifferentClass(); :}
					|	(RelopLessClass) LESS {: RESULT=new RelopLessClass(); :}
					|	(RelopElessClass) ELESS {: RESULT=new RelopElessClass(); :}
					|	(RelopGreaterClass) GREATER {: RESULT=new RelopGreaterClass(); :}
					|	(RelopEgreaterClass) EGREATER {: RESULT=new RelopEgreaterClass(); :};

//Done
Addop				::= (AddopPlusClass) PLUS {: RESULT=new AddopPlusClass(); :}
					|	(AddopMinusClass) MINUS {: RESULT=new AddopMinusClass(); :};

//Done
Mulop				::= (MulopMulClass) MUL {: RESULT=new MulopMulClass(); :}
					| 	(MulopDivClass) DIV {: RESULT=new MulopDivClass(); :}
					|	(MulopModClass) MOD {: RESULT=new MulopModClass(); :};
