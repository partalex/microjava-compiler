package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;

import rs.ac.bg.etf.pp1.ast.*;

parser code {:

	boolean errorDetected = false;

	Logger log = Logger.getLogger(getClass());


    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke

    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }

    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }

    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
    	errorDetected = true;
    	StringBuilder msg = new StringBuilder(message);
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }

    public void report_info(String message, Object info) {
    	StringBuilder msg = new StringBuilder(message);
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.info(msg.toString());
    }

:}

scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null)
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}

terminal PROG, BREAK, CLASS, CONST, IF, WHILE, NEW, ELSE, PRINT, READ, RETURN, VOID, EXTENDS, CONTINUE;
terminal SEMI, COMMA, DOT, LPAREN, RPAREN, LBRACE, RBRACE, LSQBRACE, RSQBRACE, QUESTION, DOUBLEDOT;
terminal PLUS, MINUS, MUL, DIV, MOD, EQUAL, PLUSPLUS, MINUSMINUS, FOREACH, LAMBDA;
terminal EQUALSTO, DIFFERENT, GREATER, EGREATER, LESS, ELESS, AND, OR;
terminal Integer NUMBER;
terminal String IDENT;
terminal String BOOL;
terminal String CHAR;

// finished
nonterminal Program;
nonterminal StaticDecl;
nonterminal ConstVal;
nonterminal OptionalArray;
nonterminal Type;
nonterminal VarDecl;
nonterminal VarDeclOne;
nonterminal Assignop;
nonterminal Relop;
nonterminal Addop;
nonterminal Mulop;
nonterminal FormPars;
nonterminal ActPars;
nonterminal Condition;
nonterminal CondFact;
nonterminal Term;
nonterminal MulopFactor;
nonterminal AddopTerm;
nonterminal Expr;
nonterminal CondTerm;
nonterminal AndCondFact;
nonterminal Designator;
nonterminal IdentOrExpr;
nonterminal Factor;
nonterminal MethodDecl;
nonterminal StatementOpt;
nonterminal DesignatorStFirst;
nonterminal DesignatorStSec;
nonterminal DesignatorStatement;
nonterminal if;
nonterminal else;

// TODO - new
nonterminal ConstDeclPart;
nonterminal ConstDecl;
nonterminal VarDeclPart;
nonterminal Statement;


Program 		    ::= (ProgramClass) PROG IDENT:program StaticDecl LBRACE MethodDecl RBRACE;

ConstVal 			::= (NumConstClass) NUMBER
					|	(CharConstClass) CHAR
					|	(BoolConstClass) BOOL;

StaticDecl          ::= (StaticDeclClass) ConstDecl VarDecl;

OptionalArray	    ::= (ArrayClass) LSQBRACE RSQBRACE
				    |   (NoArrayClass);

Type                ::= (TypeClass) IDENT:type;

VarDecl             ::= (VarDeclClass) VarDecl COMMA VarDeclOne
                    |   (VarDeclClass) VarDeclOne;

VarDeclOne          ::= (VarDeclOneClass) Type IDENT:name OptionalArray;

Assignop		    ::= (EqualClass) EQUAL;

Relop				::= (EqualstoClass) EQUALSTO
					|	(DifferentClass) DIFFERENT
					|	(LessClass) LESS
					|	(ElessClass) ELESS
					|	(GreaterClass) GREATER
					|	(EgreaterClass) EGREATER;

Addop				::= (PlusClass) PLUS
					|	(MinusClass) MINUS;

Mulop				::= (MulClass) MUL
					| 	(DivClass) DIV
					|	(ModClass) MOD;

FormPars            ::= (FormParsClass) FormPars COMMA Type IDENT:name OptionalArray
                    |   (FormParsClass) Type IDENT:name OptionalArray;


ActPars             ::= (ActPars) ActPars COMMA Expr
                    |   (ActPars) Expr;

Condition           ::= (ConditionClass) Condition OR CondTerm
                    |   (ConditionClass) CondTerm;

CondFact            ::= (CondFactClass) Expr Relop Expr
                    |   (CondFactClass) Expr;

MulopFactor         ::= (MulopFactorClass) MulopFactor Mulop Factor
                    |   (MulopFactorClass) Factor
                    |   (MulopFactorClass);

Term                ::= (TermClass) Factor MulopFactor;

AddopTerm           ::= (AddopTermClass) AddopTerm Addop Term
                    |   (AddopTermClass) Addop Term
                    |   (AddopTermClass);

Expr                ::= (ExprClass) MINUS Term AddopTerm
                    |   (ExprClass) Term AddopTerm;

AndCondFact         ::= (AndCondFactClass) AndCondFact AND CondFact
                    |   (AndCondFactClass) AND CondFact
                    |   (AndCondFactClass);

CondTerm            ::= (CondTermClass) CondFact AndCondFact;

IdentOrExpr         ::= (IdentExprClass) IdentOrExpr DOT IDENT
                    |   (IdentExprClass) DOT IDENT
                    |   (IdentExprClass) IdentOrExpr LSQBRACE Expr RSQBRACE
                    |   (IdentExprClass) LSQBRACE Expr RSQBRACE
                    |   (IdentExprClass);

Designator          ::= (DesignatorClass) IDENT IdentOrExpr;

Factor              ::= (FactorClass) Designator LPAREN ActPars RPAREN
                    |   (FactorClass) Designator LPAREN RPAREN
                    |   (FactorClass) Designator
                    |   (FactorClass) ConstVal
                    |   (FactorClass) NEW Type LSQBRACE Expr RSQBRACE
                    |   (FactorClass) NEW Type LPAREN ActPars RPAREN
                    |   (FactorClass) NEW Type LPAREN RPAREN
                    |   (FactorClass) LPAREN Expr RPAREN;


StatementOpt        ::= (StatementOptClass) StatementOpt Statement
                    |   (StatementOptClass) Statement
                    |   (StatementOptClass);

MethodDecl          ::= (MethodDeclClass) Type IDENT LPAREN FormPars RPAREN VarDeclPart LBRACE StatementOpt RBRACE
                    |   (MethodDeclClass) VOID IDENT LPAREN FormPars RPAREN VarDeclPart LBRACE StatementOpt RBRACE
                    |   (MethodDeclClass) Type IDENT LPAREN RPAREN VarDeclPart LBRACE StatementOpt RBRACE
                    |   (MethodDeclClass) VOID IDENT LPAREN RPAREN VarDeclPart LBRACE StatementOpt RBRACE;

DesignatorStatement ::= (DesignatorStatementClass) DesignatorStFirst
                    |   (DesignatorStatementClass) LSQBRACE Designator DesignatorStSec RSQBRACE EQUAL Designator
                    |   (DesignatorStatementClass) LSQBRACE DesignatorStSec RSQBRACE EQUAL Designator;


DesignatorStFirst   ::= (DesignatorStFirstClass) Designator Assignop Expr
                    |   (DesignatorStFirstClass) Designator LPAREN RPAREN
                    |   (DesignatorStFirstClass) Designator LPAREN ActPars RPAREN
                    |   (DesignatorStFirstClass) Designator PLUSPLUS
                    |   (DesignatorStFirstClass) Designator MINUSMINUS;

DesignatorStSec     ::= (DesignatorStSecClass) COMMA Designator
                    |   (DesignatorStSecClass) COMMA
                    |   (DesignatorStSecClass) DesignatorStSec COMMA
                    |   (DesignatorStSecClass) DesignatorStSec COMMA DesignatorStSec
                    |   (DesignatorStSecClass);

if					::= (IfClass) IF;

else 				::= (ElseClass) ELSE;

// TODO - Conflict start ----------------------------------------------------------------------------------------------------------

// ConstDecl = "const" Type ident"="(numConst | charConst | boolConst) {, ident "=" (numConst | charConst | boolConst)} ";".

ConstDecl           ::= (ConstDeclClass) CONST Type IDENT:name EQUAL ConstVal:value ConstDeclPart SEMI;

ConstDeclPart       ::= (ConstDeclPartClass) ConstDeclPart COMMA IDENT:name EQUAL ConstVal:value
                    |   (ConstDeclPartClass) COMMA IDENT:name EQUAL ConstVal:value // ako zakomentarisem ovu liniju nemam conflict
                    |   (ConstDeclPartClass);

// TODO - Conflict end  ----------------------------------------------------------------------------------------------------------

VarDeclPart         ::= (VarDeclPartClass) VarDecl
//                    |   (VarDeclPartClass) VarDeclPart VarDecl
                    |   (VarDeclPartClass);

//Statement           ::= (StatementClass) DesignatorStatement SEMI
//                    |   (StatementClass) if LPAREN Condition RPAREN Statement
//                    |   (StatementClass) if LPAREN Condition RPAREN Statement else Statement
//                    |   (StatementClass) WHILE LPAREN Condition RPAREN Statement
//                    |   (StatementClass) BREAK SEMI
//                    |   (StatementClass) CONTINUE SEMI
//                    |   (StatementClass) RETURN Expr SEMI
//                    |   (StatementClass) RETURN SEMI
//                    |   (StatementClass) READ LPAREN Designator RPAREN SEMI
//                    |   (StatementClass) PRINT LPAREN Expr RPAREN SEMI
//                    |   (StatementClass) PRINT LPAREN Expr COMMA NUMBER RPAREN SEMI
//                    |   (StatementClass) LBRACE StatementOpt RBRACE;
//                    | Designator "." "foreach" "(" ident "=>" Statement ")" ";" * za B i C nivo
