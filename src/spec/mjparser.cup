package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;

import rs.ac.bg.etf.pp1.ast.*;

parser code {:

	boolean errorDetected = false;

	Logger log = Logger.getLogger(getClass());


    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke

    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }

    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }

    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
    	errorDetected = true;
    	StringBuilder msg = new StringBuilder(message);
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }

    public void report_info(String message, Object info) {
    	StringBuilder msg = new StringBuilder(message);
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.info(msg.toString());
    }

:}

scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null)
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}

terminal PROG, BREAK, ELSE, CONST, IF, NEW, PRINT, READ, RETURN, VOID, CONTINUE, FOR, NAMESPACE;
terminal PLUS, MINUS, MUL, DIV, MOD;
terminal EQUALSTO, DIFFERENT, GREATER, EGREATER, LESS, ELESS, AND, OR;
terminal EQUAL, PLUSPLUS, MINUSMINUS;
terminal SEMI, DOUBLEDOT, COMMA, LPAREN, RPAREN, LSQBRACE, RSQBRACE, LBRACE, RBRACE;
terminal LAMBDA, DOUBLECOLON;
terminal String BOOL;
terminal String CHAR;
terminal Integer NUMBER;
terminal String IDENT;

nonterminal NamespaceMany;
nonterminal ConstDeclOptMany;
nonterminal VarDeclOptMany;
nonterminal MethodDeclOptMany;
nonterminal ConstDecl;
nonterminal ConstList;
nonterminal VarDecl;
nonterminal VarDeclOpt;
nonterminal FormParsOptOne;
nonterminal FormPars;
nonterminal OptMinus;
nonterminal OptActPars;
nonterminal DesignStatementOpt;
nonterminal OptPrint;
nonterminal Statement;
nonterminal StatementMany;
nonterminal DesignatorStatePart;
nonterminal DesignatorStatement;
nonterminal ActPars;
nonterminal ActPartsOpt;
nonterminal OptArray;
nonterminal OptExpr;
nonterminal OptFactorParenPars;
nonterminal Assignop;
nonterminal Relop;
nonterminal Addop;
nonterminal Mulop;
nonterminal VarDeclList;
nonterminal FormParsList;
nonterminal ConditionStatement;
nonterminal For;
nonterminal ConditionStart;
nonterminal ConditionEnd;
nonterminal EndFor; //ovo ne treba
nonterminal GlobalEnd; //ovo ne treba
nonterminal DesignatorStatementManyClassStart;
nonterminal NamespaceFinished;

nonterminal rs.etf.pp1.symboltable.concepts.Struct Type;
nonterminal rs.etf.pp1.symboltable.concepts.Struct Term;
nonterminal rs.etf.pp1.symboltable.concepts.Struct Factor;
nonterminal rs.etf.pp1.symboltable.concepts.Struct MethodType;
nonterminal rs.etf.pp1.symboltable.concepts.Struct ConstVal;
nonterminal rs.etf.pp1.symboltable.concepts.Struct Expr;
nonterminal rs.etf.pp1.symboltable.concepts.Struct Condition;
nonterminal rs.etf.pp1.symboltable.concepts.Struct CondTerm;
nonterminal rs.etf.pp1.symboltable.concepts.Struct CondFact;
nonterminal rs.etf.pp1.symboltable.concepts.Struct AddTerm;
nonterminal rs.etf.pp1.symboltable.concepts.Struct CondFactOpt;

nonterminal rs.etf.pp1.symboltable.concepts.Obj Program;
nonterminal rs.etf.pp1.symboltable.concepts.Obj ProgramName;
nonterminal rs.etf.pp1.symboltable.concepts.Obj Namespace;
nonterminal rs.etf.pp1.symboltable.concepts.Obj NamespaceName;
nonterminal rs.etf.pp1.symboltable.concepts.Obj OptNamespace;
nonterminal rs.etf.pp1.symboltable.concepts.Obj MethodTypeName;
nonterminal rs.etf.pp1.symboltable.concepts.Obj MethodDecl;
nonterminal rs.etf.pp1.symboltable.concepts.Obj Designator;
nonterminal rs.etf.pp1.symboltable.concepts.Obj DesignatorName;
nonterminal rs.etf.pp1.symboltable.concepts.Obj OptMatrix;
nonterminal rs.etf.pp1.symboltable.concepts.Obj ArraySize;
nonterminal rs.etf.pp1.symboltable.concepts.Obj ConstDeclPart;
nonterminal rs.etf.pp1.symboltable.concepts.Obj VarDeclPart;


nonterminal If;
nonterminal Else;

precedence left ELSE;

// Done
Program 		    ::= (Program) PROG ProgramName NamespaceMany NamespaceFinished ConstDeclOptMany VarDeclOpt GlobalEnd MethodDeclOptMany RBRACE;

NamespaceFinished   ::= (NamespaceFinished) /* epsilon */;

GlobalEnd		    ::= (GlobalEnd) LBRACE;

ProgramName		    ::= (ProgramName) IDENT:programName;

Namespace 		    ::= (Namespace) NAMESPACE NamespaceName LBRACE ConstDeclOptMany VarDeclOpt LBRACE MethodDeclOptMany RBRACE RBRACE;

NamespaceName 		::= (NamespaceName) IDENT:namespaceName;

NamespaceMany       ::= (NamespaceManyClass) NamespaceMany Namespace
                    |   (NamespaceManyEmptyClass) /* epsilon */;
MethodDeclOptMany	::= (MethodDeclOptManyClass) MethodDeclOptMany MethodDecl
					|	(MethodDeclOptEmptyClass) /* epsilon */;

// Done
OptArray		    ::= (OptArrayOne) LSQBRACE RSQBRACE
					|	(OptArrayZero) /* epsilon */;

// Done
VarDeclPart         ::= (VarDeclPart) IDENT:name OptArray;

// Done
VarDeclList         ::= (VarDeclListMany) VarDeclList COMMA VarDeclPart
                    |	(VarDeclListOne) VarDeclPart
                    |   error SEMI:l {: parser.report_error("Sintaksa greska deklaracije globalne promenljive na liniji " + lleft, null); :};

ConstDeclOptMany    ::= (ConstDeclOptManyClass) ConstDeclOptMany ConstDecl // TODO
					|	(ConstDeclOptZero) /* epsilon */;

// Done
ConstDecl           ::= (ConstDecl) CONST Type ConstDeclPart SEMI;

// Done
ConstList           ::= (ConstListMany) ConstList COMMA ConstDeclPart
                    |   (ConstListOne) ConstDeclPart;

// Done
ConstDeclPart       ::= (ConstDeclPart) IDENT:name EQUAL ConstVal:value;

// Done
VarDecl             ::= (VarDecl) Type VarDeclList SEMI;

VarDeclOpt          ::= (VarDeclOptManyClass) VarDeclOpt VarDecl
                    |   (VarDeclOptEmptyClass) /* epsilon */;

// Done
MethodType			::= (MethodTypeVoid) VOID
					|	(MethodTypeType) Type;

MethodTypeName		::= (MethodTypeName) MethodType IDENT:methodName;

MethodDecl          ::= (MethodDecl) MethodTypeName LPAREN FormParsOptOne RPAREN VarDeclOpt LBRACE StatementMany RBRACE;

// Done
FormParsOptOne      ::= (FormParsOptOne) FormParsList
                    |   (FormParsOptOneZero) /* epsilon */;

// Done
FormParsList        ::= (FormParsListMany) FormParsList COMMA FormPars
                    |   (FormParsListOne) FormPars;

// Done
FormPars            ::= (FormPars) Type IDENT:name OptArray;

// Done
Type                ::= (Type) IDENT:name;

// TODO
StatementMany       ::= (StatementMany) StatementMany Statement
                    |   (StatementZero) /* epsilon */;

// Done
OptExpr				::= (OptExprOne) Expr
					| 	(OptExprZero) /* epsilon */;

Statement           ::= (StatementDesignatorClass) DesignatorStatement SEMI
                    |   (StatementIfClass) If ConditionStatement Statement
                    |   (StatementIfElseClass) If ConditionStatement Statement Else Statement
                    |   (StatementBreakClass) BREAK SEMI // Done
                    |   (StatementContinueClass) CONTINUE SEMI // Done
                    |   (StatementReturnClass) RETURN OptExpr SEMI // Done
                    |   (StatementReadClass) READ LPAREN Designator RPAREN SEMI
                    |   (StatementPrintClass) PRINT LPAREN Expr OptPrint RPAREN SEMI // Done
                    |   (StatementForClass) For LPAREN DesignStatementOpt ConditionStart CondFactOpt SEMI DesignStatementOpt ConditionEnd Statement EndFor // Done
                    |   (StatementManyClass) LBRACE StatementMany RBRACE; // Done

// Done
ConditionStatement  ::= (ConditionStatement) LPAREN Condition RPAREN;

// Done
DesignStatementOpt  ::= (DesignStatementOptMany) DesignStatementOpt COMMA DesignatorStatement
                    |	  (DesignStatementOptOne) DesignatorStatement
                    |	  (DesignStatementOptZero) /* epsilon */;

// Done
If					::= (If) IF;

// Done
Else 				::= (Else) ELSE;

// Done
For 				::= (For) FOR;

// Done
EndFor              ::= (EndFor) /* epsilon */;

// Done
ConditionStart 	    ::= (ConditionStart) SEMI;

// Done
ConditionEnd        ::= (ConditionEnd) RPAREN;

// Done
CondFactOpt         ::= (CondFactOptOne) CondFact
                    |	(CondFactOptZero) /* epsilon */;

// Done
OptPrint	        ::= (OptPrintOne) COMMA NUMBER
					|	(OptPrintZero) /* epsilon */;

DesignatorStatePart ::= (DesignatorStatePartManyClass) DesignatorStatePart Designator COMMA
                    |   (DesignatorStatePartOneClass) DesignatorStatePart COMMA
                    |   (DesignatorStatePartEmptyClass) /* epsilon */;

DesignatorStatement ::= (DesignatorStatementAssignClass) Designator Assignop Expr
                    |   (DesignatorStatementParamsClass) Designator LPAREN ActPartsOpt RPAREN
                    |   (DesignatorStatementPlusClass) Designator PLUSPLUS
                    |   (DesignatorStatementMinusClass) Designator MINUSMINUS
                    |   (DesignatorStatementManyClass) DesignatorStatementManyClassStart DesignatorStatePart MUL Designator RSQBRACE Assignop Designator;

DesignatorStatementManyClassStart        ::= (DesignatorStatementManyClassStart) LSQBRACE;

// Done
ActPartsOpt	        ::= (ActPartsOptOne) ActPars
					|	(ActPartsOptZero) /* epsilon */;

// Done
ActPars             ::= (ActParsMany) ActPars COMMA Expr
                    |   (ActParsOne) Expr;

// Done
Condition           ::= (ConditionMany) Condition OR CondTerm
                    |   (ConditionOne) CondTerm;

// Done
CondTerm            ::= (CondTermManyClass) CondTerm AND CondFact
                    |   (CondTermOneClass) CondFact;

// Done
CondFact            ::= (CondFactMany) Expr Relop Expr
                    |   (CondFactOne) Expr;

// Done
AddTerm				::= (AddTermMany) AddTerm Addop Term
					|	(AddTermZero) /* epsilon */;

// Done
Expr                ::= (Expr) OptMinus Term AddTerm;

// Done
OptMinus 			::= (Minus) MINUS
					|	(NoMinus) /* epsilon */;

// Done
Term                ::= (TermMany) Term Mulop Factor
                    |   (TermOne) Factor;

// Done
ConstVal 			::= (ConstValNum) NUMBER
					|	(ConstValChar) CHAR
					|	(ConstValBoo) BOOL;

// Done
Factor              ::= (FactorParenPars) Designator OptFactorParenPars
                    |   (FactorConstVal) ConstVal
                    |   (FactorNewTypeExpr) NEW Type LSQBRACE Expr RSQBRACE
                    |   (FactorParenExpr) LPAREN Expr RPAREN;

// Done
OptFactorParenPars  ::= (ParenPars) LPAREN OptActPars RPAREN
                    |   (OptFactorZero) /* epsilon */;

// Done
OptActPars          ::= (ActParsOne) ActPars
                    |   (ActParsZero) /* epsilon */;

// Done
OptNamespace        ::= (WithNamespace) IDENT:namespace DOUBLECOLON IDENT:name
                    |   (NoNamespace) IDENT:name;

// Done
Designator          ::= (Designator) OptNamespace OptMatrix;

// Done
OptMatrix           ::= (MatrixMany) OptMatrix ArraySize
                    |   (MatrixZero) /* epsilon */;

// Done
ArraySize			::= (ArraySize) LSQBRACE Expr RSQBRACE;

// Done
Assignop		    ::= (Assignop) EQUAL
                    |	error SEMI:l {: parser.report_error("Sintaksa greska dodele na liniji " + lleft, null); :};

// Done
Relop				::= (RelopEqualsto) EQUALSTO
					|	(RelopDifferent) DIFFERENT
					|	(RelopLess) LESS
					|	(RelopEless) ELESS
					|	(RelopGreater) GREATER
					|	(RelopEgreater) EGREATER;

// Done
Addop				::= (AddopPlus) PLUS
					|	(AddopMinus) MINUS;

// Done
Mulop				::= (MulopMul) MUL
					| 	(MulopDiv) DIV
					|	(MulopMod) MOD;
